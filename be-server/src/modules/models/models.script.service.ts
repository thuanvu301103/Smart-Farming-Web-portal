import {
    Injectable, Inject, forwardRef,
    NotFoundException, BadRequestException,
    ConflictException,
    InternalServerErrorException,
    HttpException, HttpStatus,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Models } from '../../schemas/models.schema';
import { ModelScript } from '../../schemas/models.scripts.schema';
import { FilesService } from "../files/files.service";
import { ConfigService } from '@nestjs/config';
import axios from 'axios';
import { Readable } from 'stream';

function bufferToStream(buffer: Buffer) {
    const stream = new Readable();
    stream.push(buffer);
    stream.push(null);
    return stream;
}

@Injectable()
export class ModelScriptsService {

    private python_server: string = 'http:10.1.8.52:7000';
    
    constructor(
        @InjectModel(Models.name) private modelModel: Model<Models>,
        @InjectModel(ModelScript.name) private modelScriptModel: Model<ModelScript>,
        @Inject(FilesService) private readonly filesService: FilesService,
        private readonly configService: ConfigService,
    ) { }

    /*----- Model Script -----*/
    async genScript(
        userId: string,
        name: string,
        version: string,
        location: string,
        temp: number,
        humid: number,
        rainfall: number
    ) {
        try {
            const response = await axios.post(
                `${this.python_server}/model-versions/generate`,
                { 
                    name: name, 
                    version: version,
                    location: location,
                    temp: temp,
                    humid: humid,
                    rainfall: rainfall 
                }
            );
            if (response.status !== 200) {
                throw new BadRequestException(`PythonServer returned status ${response.status}`);
            }
            const fileBuffer = Buffer.from(response.data, 'utf-8');
            const scriptFile: Express.Multer.File = {
                fieldname: 'file',
                originalname: `script.json`,
                encoding: '7bit',
                mimetype: 'application/json',
                size: fileBuffer.length,
                buffer: fileBuffer,
                stream: bufferToStream(fileBuffer),
                destination: '',
                filename: '',
                path: ''
            };
            const scriptFiles: Express.Multer.File[] = [scriptFile];
            await this.filesService.uploadFilesToFTP(scriptFiles, `/${userId}/model/${name}/script`);
            const newModelScript = new this.modelScriptModel({
                model_name: name,
                model_version: version,
                location: location,
                avg_temp: temp,
                avg_humid: humid,
                avg_rainfall: rainfall,
                owner_id: new Types.ObjectId(userId)
            })
            const savedModelScript = await newModelScript.save();
            return savedModelScript;
        } catch (error) {
            if (error.response) {
                throw new HttpException(
                    `Python Server Error: ${error.response.data.message || 'Unknown error'}`,
                    error.response.status || HttpStatus.INTERNAL_SERVER_ERROR
                );
            }
            throw new HttpException(
                `Failed to connect to Python Server API. Check your pythonUrl.`,
                HttpStatus.SERVICE_UNAVAILABLE
            );
        }
    }

    //////////////////////////////////////////////////////////////////////////
    
    // Upload Model Script
    async uploadModelScript(scriptFiles, version, user_id, model_id, model_version) {
        if (await this.isVersionExist(model_id, version)) {
            throw new ConflictException(`Model Script Version ${version} already exists`);
        }
        const newModelScript = new this.modelScriptModel({
            //version: version,
            //model_id: new Types.ObjectId(model_id),
            model_version: model_version
        })
        const savedModelScript = await newModelScript.save();
        for (const file of scriptFiles) {
            file.originalname = `version${version}.json`
        }
        console.log("DYNAMIC FILE", scriptFiles)
        if (savedModelScript && savedModelScript._id) {
            await this.filesService.uploadFilesToFTP(scriptFiles, `/${user_id}/model/${model_id}/script`)
        } else {
            throw new InternalServerErrorException('Error while saving Model Script');
        }
    }

    // Check if Model Script / Version is exist or not
    async isVersionExist(model_id, version) {
        const scripts = await this.getAllModelScripts(model_id);
        const versions = scripts.map(script => script.version);
        //console.log(versions);
        return versions.includes(version);
    }

    // get all Model Script generated by a Model
    async getAllModelScripts(model_id) {
        const scripts = await this.modelScriptModel.find({ model_id: new Types.ObjectId(model_id) }).lean().exec();
        return scripts;
    }

    // get a Model Script
    async getModelScript(user_id, model_id, script_version) {
        return await this.filesService.getFileContent(`${user_id}/model/${model_id}/script/version${script_version}.json`);
    }

    // Delete scripts
    async deleteModelScript(userId, modelScriptId) {
        const deletedModelScript = await this.modelScriptModel.findByIdAndDelete(modelScriptId);
        if (deletedModelScript) {
            await this.filesService.deleteFileFromFTP(`/${userId}/model/${deletedModelScript.model_id.toString()}/script/version${deletedModelScript.version}.json`)
        } else {
            throw new InternalServerErrorException('Error while deleting Model Script');
        }
    }
}
