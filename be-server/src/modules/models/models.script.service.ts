import {
    Injectable, Inject, forwardRef,
    NotFoundException, BadRequestException,
    ConflictException,
    InternalServerErrorException,
    HttpException, HttpStatus,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Models } from '../../schemas/models.schema';
import { ModelScript } from '../../schemas/models.scripts.schema';
import { FilesService } from "../files/files.service";
import { ConfigService } from '@nestjs/config';
import axios from 'axios';

@Injectable()
export class ModelScriptsService {

    constructor(
        @InjectModel(Models.name) private modelModel: Model<Models>,
        @InjectModel(ModelScript.name) private modelScriptModel: Model<ModelScript>,
        @Inject(FilesService) private readonly filesService: FilesService,
        private readonly configService: ConfigService,
    ) { }

    // Upload Model Script
    async uploadModelScript(scriptFiles, version, user_id, model_id, model_version) {
        if (await this.isVersionExist(model_id, version)) {
            throw new ConflictException(`Model Script Version ${version} already exists`);
        }
        const newModelScript = new this.modelScriptModel({
            version: version,
            model_id: new Types.ObjectId(model_id),
            model_version: model_version
        })
        const savedModelScript = await newModelScript.save();
        for (const file of scriptFiles) {
            file.originalname = `version${version}.json`
        }
        if (savedModelScript && savedModelScript._id) {
            await this.filesService.uploadFilesToFTP(scriptFiles, `/${user_id}/model/${model_id}/script`)
        } else {
            throw new InternalServerErrorException('Error while saving Model Script');
        }
    }

    // Check if Model Script / Version is exist or not
    async isVersionExist(model_id, version) {
        const scripts = await this.getAllModelScripts(model_id);
        const versions = scripts.map(script => script.version);
        //console.log(versions);
        return versions.includes(version);
    }

    // get all Model Script generated by a Model
    async getAllModelScripts(model_id) {
        const scripts = await this.modelScriptModel.find({ model_id: new Types.ObjectId(model_id) }).lean().exec();
        return scripts;
    }

    // get a Model Script
    async getModelScript(user_id, model_id, script_version) {
        return await this.filesService.getFileContent(`${user_id}/model/${model_id}/script/version${script_version}.json`);
    }

    // Delete scripts
    async deleteModelScript(userId, modelScriptId) {
        const deletedModelScript = await this.modelScriptModel.findByIdAndDelete(modelScriptId);
        if (deletedModelScript) {
            await this.filesService.deleteFileFromFTP(`/${userId}/model/${deletedModelScript.model_id.toString()}/script/version${deletedModelScript.version}.json`)
        } else {
            throw new InternalServerErrorException('Error while deleting Model Script');
        }
    }
}
